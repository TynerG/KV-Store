
// bool SSTController::save(vector<array<int, 2>> theKVPairs) {
//     if (theKVPairs.empty()) return true;
//     std::cerr << "WRITING DATA\n";

//     // open with direct I/O
//     std::string newPath = newSSTPath();
//     const char *sstPath = newPath.c_str();

//     int fd = open(sstPath, O_WRONLY | O_CREAT | O_DIRECT, 0777);
//     if (fd <= 0) {
//         std::cerr << "Error opening file for direct I/O: " << strerror(errno)
//                   << std::endl;
//         return false;
//     }

//     int blockSize = PAGE_SIZE;  // must be a multiple of 512 bytes
//     char *buffer = nullptr;

//     // allocate aligned memory for direct I/O
//     if (posix_memalign((void **)&buffer, 512, blockSize) != 0) {
//         std::cerr << "Error allocating aligned memory for direct I/O"
//                   << std::endl;
//         close(fd);
//         return false;
//     }

//     size_t totalPairs = theKVPairs.size();
//     size_t totalSize = totalPairs * KVPAIR_SIZE;
//     size_t numPages = (totalSize + PAGE_SIZE - 1) / PAGE_SIZE;
//     size_t numKVPairsInPage = PAGE_SIZE / KVPAIR_SIZE;

//     // write the data page by page
//     size_t pairsWritten = 0;
//     for (size_t pageNum = 0; pageNum < numPages; ++pageNum) {
//         // calculate how many key-value pairs can fit in the current page
//         size_t numKVPairsToWrite =
//             std::min(numKVPairsInPage, totalPairs - pairsWritten);

//         // copy the data for this page into the buffer
//         memcpy(buffer, theKVPairs.data() + pairsWritten,
//                numKVPairsToWrite * KVPAIR_SIZE);
//         // if this is the last page and it's not full, pad the remaining
//         space with zeroes if (numKVPairsToWrite < numKVPairsInPage) {
//             memset(buffer + numKVPairsToWrite * KVPAIR_SIZE, 0,
//                    (numKVPairsInPage - numKVPairsToWrite) * KVPAIR_SIZE);
//         }

//         // write the buffer to the SST file
//         ssize_t result = write(fd, buffer, numKVPairsToWrite * KVPAIR_SIZE);
//         if (result == -1) {
//             std::cerr << "Error writing data: " << strerror(errno)
//                       << " (errno: " << errno << ")" << std::endl;
//             free(buffer);
//             close(fd);
//             return false;
//         }

//         // update the number of pairs written
//         pairsWritten += numKVPairsToWrite;
//     }

//     free(buffer);
//     close(fd);

//     // update the metadata
//     myNumSST++;
//     updateMetaData();

//     return true;
// }

// vector<array<int, 2>> SSTController::readSST(int theSSTIdx) {
//     // open file with DIRECT I/O to by pass OS cache
//     std::string path = existingSSTPath(theSSTIdx);
//     const char *sstPath = path.c_str();
//     int fd = open(sstPath, O_RDONLY | O_DIRECT);
//     if (fd <= 0) {
//         throw runtime_error("Error opening file for direct I/O");
//     }

//     int blockSize = PAGE_SIZE;  // must be a multiple of 512 bytes
//     char *buffer = nullptr;
//     // allocate memory on page boundary
//     if (posix_memalign((void **)&buffer, blockSize, blockSize) != 0) {
//         std::cerr << "Error allocating aligned memory for direct I/O"
//                   << std::endl;
//         close(fd);
//         throw runtime_error("Memory allocation failed");
//     }

//     int numKVPairs = blockSize / KVPAIR_SIZE;
//     vector<array<int, 2>> allKVPairs;
//     int pageNum = 0;

//     // readSST the file page by page
//     while (true) {
//         // check buffer pool for page first
//         vector<array<int, 2>> pageKVPairs =
//             bufferPool.getPage(theSSTIdx, pageNum);

//         if (pageKVPairs.empty()) {
//             // page not in buffer pool, so do an I/O and add the page to
//             buffer
//             // pool
//             vector<array<int, 2>> ioKVPairs(numKVPairs);

//             ssize_t result = read(fd, buffer, blockSize);
//             if (result == 0) {
//                 break;  // End of file
//             }
//             if (result <= 0) {
//                 std::cerr << "Error reading data: " << strerror(errno)
//                           << std::endl;
//                 free(buffer);
//                 close(fd);
//                 throw runtime_error("Error reading SSTs");
//             }

//             allKVPairs.resize(allKVPairs.size() + numKVPairs);
//             // copy data from buffer to vector
//             memcpy(pageKVPairs.data(), buffer, result);
//         }

//         // add to all
//         allKVPairs.insert(allKVPairs.end(), pageKVPairs.begin(),
//                           pageKVPairs.end());
//         pageNum++;
//     }

//     free(buffer);
//     close(fd);
//     return allKVPairs;
// }
